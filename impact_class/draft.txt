	// private void circle_spiral_impl(ArrayList<R_Line2D> web_string, vec2 offset, float dist) {
	// 	float start_angle = 0;

	// 	float step_angle = TAU / get_num_main();
	// 	vec2 ang_set = new vec2(start_angle, step_angle);
	// 	vec2 buf_meet = new vec2(-1);
	// 	int count = 0;
	// 	boolean jump_is = false;
	// 	float buf_dist = dist;

	//   while(count < get_iter_circle()) {
	// 		R_Line2D line = draw_string_web(ang_set, offset, buf_dist);
	// 		// here we catch the meeting point with the main branches
	// 		vec2 [] tupple = meet_point(line, true);
	// 		boolean good_tupple_is = false;
	// 		if(tupple[0] != null && tupple[1] != null) {
	// 			good_tupple_is = true;
	// 			// the moment where the turn is done and it's time to go to next level
	// 			if((count+1)%get_num_main() == 0) {
	// 				vec2 swap = tupple[0];
	// 				tupple[0] = tupple[1];
	// 				tupple[1] = swap;
	// 			}
	// 		}
	// 		jump_is = adjust_string_web(web_string, line, buf_meet, tupple, good_tupple_is, jump_is);

	// 		count++;
	// 		buf_dist = dist(line.b(),offset);
	//   }
	// }

	// private void circle_line_impl(ArrayList<R_Line2D> web_string, vec2 offset, float dist) {
	// 	float start_angle = 0;

	// 	float step_angle = TAU / get_num_main();
	// 	vec2 ang_set = new vec2(start_angle, step_angle);
	// 	vec2 buf_meet = new vec2(-1);
	// 	int count = 0;
	// 	boolean jump_is = false;
	// 	float buf_dist = dist;

	//   while(count < get_iter_circle()) {
	// 		R_Line2D line = draw_string_web(ang_set, offset, buf_dist);
	// 		// here we catch the meeting point with the main branches
	// 		vec2 [] tupple = meet_point(line, true);
	// 		boolean good_tupple_is = false;
	// 		if(tupple[0] != null && tupple[1] != null) {
	// 			good_tupple_is = true;
	// 		}
	// 		jump_is = adjust_string_web(web_string, line, buf_meet, tupple, good_tupple_is, jump_is);
	// 		count++;
	// 		if(count%get_num_main() == 0 && count <= web_string.size()) {
	// 			int which_one = count - get_num_main();
	// 			close_string_web(web_string, which_one);
	// 		}
	//   }
	// }